

# archeoviz

## bugs 

* TODO vérifier que `class.variable` et `class.values` sont supportés comme para URL
* Statistiques / le tableau "variable", lorsqu'utilisé avec "fuzzy" + "exact" modifie les rownames (ajoute des points dans les espaces)
* bug dans la génération des svg pour les profils (les lignes qui délimitent la figure sont décalées)
* Densité 2D : erreurs occasionnelles lorsqu'impossibilité de générer les courbes de densité
* Cassenade : plot 3D, hull + refits : impossible de bouger la visualisation 3D

## simple enhancements

* bouton Lancer / Rafraîchir
* add test for: reverse.axis.values,  reverse.square.names, do_r_command, .do_square_list
* améliorer les labels pour les adapter lors de la représentation de grandes surfaces
* voir si le slider de timeline peut gérer des dates (et non des nombres)
* employer les données 3D "volcano"  pour voir le comportement de convex hull et reression surface pour représenter des surfaces (ex : structures en creux)

## new features

* permettre de croiser 2 variables dans les visualisations en employant couleur et symboles
* permettre la timeline par mois ou par jours. Limite: implique une dépendance à shinyWidgets::sliderTextInput()
	https://stackoverflow.com/questions/40392676/r-shiny-date-slider-animation-by-month-currently-by-day/40402610#40402610
		if(sum(grepl("^[0-9]{4}$", timeline.df$year)) == nrow(timeline.df)){
		  timeline.df$year <- paste0(timeline.df$year, "-01-01")
		  step <- 365
		  timeFormat <- "%Y"
		} else if(sum(grepl("^.*-.*$", timeline.df$year)) == nrow(timeline.df)){
		  timeline.df$year <- paste0(timeline.df$year, "-01")
		  step <- 30
		  timeFormat <- "%Y-%m"
		} else if(sum(grepl("^.*-.*-.*$", timeline.df$year)) == nrow(timeline.df)){
		  step <- 1
		  timeFormat <- "%Y-%m-%d"
		}
		timeline.df$year <- as.Date(timeline.df$year)
		
* modifier l'interface pour clarifier que les remontages sont aussi des fabriques
* analyse des orientations des remontages / fabrique
* rendre possible le rearrangement des labels de carré : square_x, square_x_order, square_y, square_y_order
* permettre de plotter les surfaces (suggestion D Giusti)
	ajouter sélecteur des sous-groupes de points pour lesquels calculer les surfaces
		if surface == TRUE, then display <value selector>
		TODO: reordonner les items dans le menu pour avoir le <value selector> pour les surfaces en bas
	voir tests de Gainesville avec Nico
* calculer des surfaces d'interface entre couches
* étendre les paramètres possibles en URL : toute la listes des "params" + les shinyOptions.
  interfaçage / openarcheo ou nakala: faire qu'il soit possible de lancer avec une url une instance archeoviz mettant en evidence un objet.
	(idée : un convertisseur tranforme l'url et ses parametres en commande archeoviz() adaptée avec les paramètres)
  Solution: une grosse fonction qui teste la présence de chaque paramètre dans l'url:
    query <- shiny::parseQueryString(session$clientData$url_search)
    
    param_static <- names(query)[ names(query) %in% c("class_variable", "class_values", "default.group", "location", "planZ", "map.density", "map.refits", "plot3d.ratio", "cxhull", "surface", "plot3d.refits", "sectionXx", "sectionXy", "refits.sectionX", "sectionYx", "sectionYy", "refits.sectionY", "camera.center", "camera.eye") ]
    
    param_dynamic <- names(query)[ names(query) %in% c("objects.df", "refits.df", "timeline.df", "square.size", "reverse.axis.values", "reverse.square.names", "add.x.square.labels", "add.y.square.labels", "title", "home.text", "lang", "set.theme", "run.plots", "html.export") ]
    
  # param_static
    sapply(param_static,  function(param_name) eval(parse( shinyOptions(param_name = query[[param_name]]) )) )
    for(x in 1:length(param_static)){
		param.list[[ names(param_dynamic) == names(param_dynamic[x]) ]] <- param_dynamic[x]
		
		eval(parse( shinyOptions(param_static[x] = query[[ names(param_static[x]) ]]) )) 
	} 
    
  # param_dynamic
	param.list <- getshinyOptions("params")
	for(x in 1:length(param_dynamic)){
		param.list[[ names(param_dynamic) == names(param_dynamic[x]) ]] <- param_dynamic[x]
	} 
	shinyOptions("params" =  param.list)
                 
                 
* integrer 3 types d'enregistrement 
	* par carré, carroyage 
	* coordonnée absolues
	* coordonnées UTM

DONE:
* voir  package explor : pour export des parametres courant d'une appli shiny
*  récupérer l'état des paramètres
		https://stackoverflow.com/questions/32460475/export-all-user-inputs-in-a-shiny-app-to-file-and-load-them-later
	
	
# portal

* ajouter Wikidata
* revoir la structure de l'arborescence sur le serveur huma-num, en utilisant le parametre path de load_all() pour n'avoir qu'une copie du package
* ajouter une rubrique “variables” (type et description), voir l'exemple de tDAR, récupérant les données dans le tableau metadata.csv
	soit 1 colonne par variable (contenant alors les 3 champs : name, type, description)
	soit 3 colonnes par variable (Column Name,	Data Type, description)
* indexation periodo + geonames pour les communes
* marquer le site sélectionné par une forme différente

* envisager la gestion d'intervalles de dates : 
	jouter une colonne contenant toutes les périodes couvertes et utiliser
	datatable(	options = list( columnDefs = list(list(visible=FALSE, targets=c(4))))  )
	pour masquer cette colonne tout en permettant qu'elle soit filtrable





## Méthode pour remontages

Deux cas de figure sont à distinguer dans les données produites par les archéologues :

1. les remontages physiques sont documentés explicitement (les relations de connexité entre fragments sont documentées par des paires d'identifiants de framents)
2. les remontages sont documentés par ensembles de fragments joins (sans préciser les relations de connexité entre fragments)

Deux variables sont à documenter dans le tableau metadata.csv
* n.refits : nombre de relations de remontage physiques (paires de fragments)
* n.remains.in.refitting.set : nombre de fragments étant inclus dans des ensembles de remontages

Parti pris : les fragments inclus dans des ensembles de remontage ne comprenant que 2 fragments sont considérés comme des "refits" (puisqu'il n'y a pas d'ambiguité à propos de la composition des paires de fragmentes remontables)









df <- demo_objects_data(30)
df <- df[ , c("id", "xmin", "ymin", "zmin", "layer", "object_type")]


df1 <- expand.grid(xmin = 1:51, ymin = 1:51)
df1$zmin <-  trunc(apply(df1, 1, function(x) sqrt((median(df1[, 1]) - x[1])^2 + (median(df1[, 2]) - x[2])^2)))
df1$zmin <- max(df1$zmin) - df1$zmin
df1$layer <- "structure1"
df1$object_type <- "hole1"
df1$id <- ""

df2 <- expand.grid(xmin = 1:51, ymin = 1:51)
df2$zmin <-  trunc(apply(df2, 1, function(x) sqrt(( median(df2[, 1]) - x[1])^2 + (median(df2[, 2]) - x[2])^2))) 
df2 <- df2 + 100
df2$zmin <- max(df2$zmin) - df2$zmin + 50
df2$layer <- "structure2"
df2$object_type <- "hole2"
df2$id <- ""

df <- rbind(df1, df2)
df$id <- 1:nrow(df)

archeoViz::archeoViz(objects.df = df,      # data.frame with data about the objects
                     refits.df = NULL,       # (optional) data.frame for refitting data
                     timeline.df = NULL,     # (optional) data.frame for the excavation timeline
                     title = NULL,           # title of the site / data set
                     home.text = NULL,       # html content to display on the home page
                     lang = "fr",            # language of the app interface
                     set.theme = "simplex")  # graphic theme for the Shiny interface


